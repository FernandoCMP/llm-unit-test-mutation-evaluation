[1] Papel
Você é um engenheiro de software especializado em testes unitários e critérios
de teste estrutural baseados em fluxo de dados.

[2] Tarefa
Gerar testes unitários em Java (JUnit 5) para o método nextPrime(int n).
Não gerar testes para outros métodos da classe.

[3] Convenções do Chain of Code

As seguintes convenções devem ser utilizadas e respeitadas durante
o raciocínio em Chain of Code:

- delta state representa o estado atualizado após a execução da instrução corrente;
- def identifica uma definição de variável;
- p_use identifica um uso predicativo;
- c_use identifica um uso computacional;
- path identifica um caminho lógico de execução;
- D1, D2, ... identificam definições distintas;
- P0, P1, ... identificam caminhos distintos.

[4] Chain of Code 

Questão: Como o método nextPrime(int n) se comporta para diferentes valores de entrada?

1   n = input_n
    delta state: { n = input_n, def = D1 }

2   cond_neg = (n < 0)
    delta state: { n = input_n, p_use = (n < 0) }

3   if cond_neg:
        exception_thrown = true
    delta state: { path = P0 }

4   cond_two = (n == 2)
    delta state: { n = input_n, p_use = (n == 2) }

5   if cond_two:
        return_value = 2
    delta state: { path = P1, return_value = 2 }

6   n = n | 1
    delta state: { n = odd(n), def = D2, c_use = (n | 1) }

7   cond_one = (n == 1)
    delta state: { n = odd(n), p_use = (n == 1) }

8   if cond_one:
        return_value = 2
    delta state: { path = P2, return_value = 2 }

9   prime_pre_loop = isPrime(n)
    delta state: { n = odd(n), c_use = isPrime(n) }

10  if prime_pre_loop:
        return_value = n
    delta state: { path = P3, return_value = n }

11  rem = n % 3
    delta state: { rem = n % 3, def = D4, c_use = (n % 3) }

12  if rem == 0:
        n = n + 2
    delta state: { n = n + 2, def = D3, p_use = (rem == 0), path = P4 }

13  if rem == 1:
        n = n + 4
    delta state: { n = n + 4, def = D3, p_use = (rem == 1), path = P5 }

14  while true:
        prime_loop = isPrime(n)
    delta state: { n = current, c_use = isPrime(n) }

15      if prime_loop:
            return_value = n
    delta state: { path = P7, return_value = n }

16      n = n + 2
    delta state: { n = n + 2, def = D3 }

17      prime_after_inc = isPrime(n)
    delta state: { n = n + 2, c_use = isPrime(n) }

18      if prime_after_inc:
            return_value = n
    delta state: { path = P8, return_value = n }

19      n = n + 4
    delta state: { n = n + 4, def = D3 }

20      continue
    delta state: { path = P9 }

21  unit_test_scenarios = derive_from_paths(P0, P1, P2, P3, P4, P5, P7, P8, P9)
    delta state: { unit_test_scenarios = complete }

Resposta: unit_test_scenarios

[5] Geração do Código Final (JUnit 5)

Com base exclusivamente no raciocínio em Chain of Code acima,
gere o código Java completo e compilável da classe de testes
JUnit 5 para o método nextPrime(int n).

[6] Requisitos

[6.1] A classe de teste não deve conter comentários, explicações ou texto fora do código Java.
[6.2] Todos os casos de teste devem possuir nomes que façam referência explícita ao método nextPrime, seguindo o padrão: testNextPrime_*.


