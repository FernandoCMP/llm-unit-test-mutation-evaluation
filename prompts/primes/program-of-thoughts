[1] Papel
Você é um engenheiro de software especializado em testes unitários e critérios
de teste estrutural baseados em fluxo de dados.

[2] Tarefa
Gerar testes unitários em Java (JUnit 5) para o método nextPrime(int n).
Não gerar testes para outros métodos da classe.

[3] Conformidade dos nomes dos casos de testes
Todos os casos de teste devem ter nomes que façam referência explícita
ao método nextPrime, como por exemplo: testNextPrime_*.

[4] Program-of-Thoughts 

Antes de gerar o código final dos testes, produza um programa de
raciocínio estrutural que modele explicitamente o comportamento do
método nextPrime(int n) com base em critérios de fluxo de dados.

Esse programa programa de raciocínio estrutural deve ser representado exclusivamente
por um objeto JSON válido.

O JSON deve capturar:
- variáveis relevantes do método;
- definições de variáveis (All-Defs);
- usos computacionais (c-use) e predicativos (p-use);
- pares definição–uso (All-Uses);
- caminhos definição–uso relevantes (DU-Paths);
- mapeamento explícito entre caminhos e casos de teste planejados.

Nesta etapa:
- NÃO escreva código Java;
- NÃO escreva texto explicativo fora do JSON;
- NÃO utilize comentários;
- NÃO gere ainda os casos de teste.

[4.1] Estrutura esperada do Program-of-Thoughts (JSON)

{
  "variables": [
    { "name": "n", "role": "parâmetro" },
    { "name": "rem", "role": "variável local" }
  ],
  "definitions": [
    { "id": "D1", "variable": "n", "description": "definição como parâmetro formal" },
    { "id": "D2", "variable": "n", "description": "redefinição por n | 1" },
    { "id": "D3", "variable": "n", "description": "redefinições por n += 2 e n += 4" },
    { "id": "D4", "variable": "rem", "description": "definição por n % 3" }
  ],
  "uses": [
    { "id": "U1", "variable": "n", "type": "p-use", "description": "condições iniciais (n < 0, n == 2, n == 1)" },
    { "id": "U2", "variable": "n", "type": "c-use", "description": "chamadas isPrime(n) e cálculos aritméticos" },
    { "id": "U3", "variable": "rem", "type": "p-use", "description": "condições rem == 0 e rem == 1" }
  ],
  "du_paths": [
    { "id": "P0", "description": "Exceção lançada para n < 0" },
    { "id": "P1", "description": "Retorno imediato para n == 2" },
    { "id": "P2", "description": "Retorno imediato para n == 1 após ajuste n | 1" },
    { "id": "P3", "description": "Retorno imediato quando isPrime(n) é verdadeiro antes do laço" },
    { "id": "P4", "description": "Ajuste inicial com rem == 0 (n += 2) antes do laço" },
    { "id": "P5", "description": "Ajuste inicial com rem == 1 (n += 4) antes do laço" },
    { "id": "P6", "description": "Entrada no laço sem ajuste inicial (rem == 2)" },
    { "id": "P7", "description": "Retorno na primeira verificação de isPrime(n) dentro do laço" },
    { "id": "P8", "description": "Retorno na segunda verificação após n += 2 dentro do laço" },
    { "id": "P9", "description": "Iteração completa do laço com n += 2 e n += 4 antes do retorno" }
  ],
  "planned_tests": [
    { "test_id": "T0", "covers": ["P0"] },
    { "test_id": "T1", "covers": ["P1"] },
    { "test_id": "T2", "covers": ["P2"] },
    { "test_id": "T3", "covers": ["P3"] },
    { "test_id": "T4", "covers": ["P4"] },
    { "test_id": "T5", "covers": ["P5"] },
    { "test_id": "T6", "covers": ["P6"] },
    { "test_id": "T7", "covers": ["P7"] },
    { "test_id": "T8", "covers": ["P8"] },
    { "test_id": "T9", "covers": ["P9"] }
  ],
  "constraints": {
    "no_intermediate_redefinition": true,
    "all_defs_covered": true,
    "all_uses_covered": true,
    "representative_loop_coverage": true
  }
}

[5] Geração do Código Final (JUnit 5)

Com base exclusivamente no Program-of-Thoughts definido na etapa anterior,
gere apenas o código Java completo e compilável da classe de teste JUnit 5
para o método nextPrime(int n).

[6] Requisitos:
- Os casos de teste devem garantir cobertura de todos os caminhos definidos em "planned_tests", sem limitar a quantidade total de testes gerados;
- Não inclua comentários, explicações ou texto fora do código Java.
