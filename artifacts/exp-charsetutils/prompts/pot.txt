[1] Papel

Você é um engenheiro de software especializado em testes unitários e critérios de teste estrutural baseados em fluxo de dados.

[2] Tarefa

Gerar testes unitários em Java (JUnit 5) para o método
squeeze(String str, String... set)
da classe org.apache.commons.lang3.CharSetUtils.

[3] Restrição de Escopo

Gerar casos de teste apenas para o método squeeze(String str, String... set).
Não criar testes para outros métodos da classe.

[3.1] Análise Estrutural Prévia do Método squeeze(String str, String... set)

O método squeeze(String str, String... set) da classe CharSetUtils foi previamente analisado
segundo critérios de teste estrutural baseados em fluxo de dados.
Essa análise deve ser considerada como base obrigatória para a construção do Program-of-Thoughts.

Variáveis do método squeeze(String str, String... set):

- str: parâmetro formal (string de entrada)
- set: parâmetro formal (array varargs de strings)
- chars: variável local (instância de CharSet)
- buffer: variável local (StringBuilder, acumulador do resultado)
- chrs: variável local (array de caracteres derivado de str)
- sz: variável local inteira (tamanho do array chrs)
- lastChar: variável local (caractere anteriormente processado)
- ch: variável local (caractere atual do laço)
- i: variável de controle do laço for

Definições (def)

Para str:
- D1: definição inicial como parâmetro formal do método

Para set:
- D2: definição inicial como parâmetro formal do método

Para chars:
- D3: definição por CharSet.getInstance(set)

Para buffer:
- D4: definição por new StringBuilder(str.length())

Para chrs:
- D5: definição por str.toCharArray()

Para sz:
- D6: definição por chrs.length

Para lastChar:
- D7: definição inicial literal ' '
- D8: redefinição de lastChar por atribuição lastChar = ch dentro do laço,
      após buffer.append(ch)

Para ch:
- D9: redefinição em cada iteração do laço (ch = chrs[i])

Para i:
- D10: definição inicial do laço for (int i = 0; ...)
- D11: redefinição implícita pelo incremento do laço

Usos predicativos (p-use)

Para str:
- P1: StringUtils.isEmpty(str)

Para set:
- P2: deepEmpty(set)

Para i:
- P3: condição do laço (i < sz)
- P4: condição (i != 0)

Para ch:
- P5: comparação (ch == lastChar)
- P6: predicado chars.contains(ch)

Usos computacionais (c-use)

Para str:
- C1: return str
- C2: str.length()
- C3: str.toCharArray()

Para set:
- C4: argumento em CharSet.getInstance(set)

Para chars:
- C5: chamada chars.contains(ch)

Para buffer:
- C6: buffer.append(ch)
- C7: buffer.toString()

Para chrs:
- C8: acesso chrs[i]

Para ch:
- C9: argumento em buffer.append(ch)
- C10: valor atribuído a lastChar

Para lastChar:
- C11: atribuição lastChar = ch

[4] Program-of-Thoughts

Antes de gerar o código final dos testes, produza um programa de raciocínio estrutural
que modele explicitamente o comportamento do método squeeze(String str, String... set)
com base em critérios de fluxo de dados.

Esse programa de raciocínio estrutural deve ser representado exclusivamente
por um objeto JSON válido.

O JSON deve capturar:
- variáveis relevantes do método;
- definições de variáveis (All-Defs);
- usos computacionais (c-use) e predicativos (p-use);
- pares definição–uso (All-Uses);
- caminhos definição–uso relevantes (DU-Paths);
- mapeamento explícito entre caminhos e casos de teste planejados.

Nesta etapa:
- Gere exclusivamente um objeto JSON válido como saída da resposta do modelo;
- O JSON é um artefato intermediário de raciocínio e NÃO faz parte da classe de testes;
- NÃO escreva texto explicativo fora do JSON;
- O código JSON dentro da classe de teste deve ser comentado com //;
- NÃO gere ainda os casos de teste.

[4.1] Estrutura esperada do Program-of-Thoughts (JSON)

{
  "semantic_roles": [
    {
      "name": "input_str",
      "description": "string de entrada fornecida ao método squeeze"
    },
    {
      "name": "input_set",
      "description": "conjunto de caracteres fornecido ao método squeeze"
    },
    {
      "name": "observable_return",
      "description": "string efetivamente retornada por squeeze(input_str, input_set)"
    }
  ],
  "variables": [
    { "name": "str", "role": "parâmetro formal" },
    { "name": "set", "role": "parâmetro formal (varargs)" },
    { "name": "chars", "role": "estrutura de conjunto de caracteres" },
    { "name": "buffer", "role": "acumulador de saída" },
    { "name": "chrs", "role": "array de caracteres de str" },
    { "name": "sz", "role": "tamanho do array chrs" },
    { "name": "lastChar", "role": "estado do caractere anterior" },
    { "name": "ch", "role": "caractere atual do laço" },
    { "name": "i", "role": "contador do laço" }
  ],
  "definitions": [
    { "id": "D1", "variable": "str", "description": "definição inicial como parâmetro formal" },
    { "id": "D2", "variable": "set", "description": "definição inicial como parâmetro formal" },
    { "id": "D3", "variable": "chars", "description": "definição por CharSet.getInstance(set)" },
    { "id": "D4", "variable": "buffer", "description": "definição por new StringBuilder(str.length())" },
    { "id": "D5", "variable": "chrs", "description": "definição por str.toCharArray()" },
    { "id": "D6", "variable": "sz", "description": "definição por chrs.length" },
    { "id": "D7", "variable": "lastChar", "description": "definição inicial literal" },
    { "id": "D8", "variable": "lastChar", "description": "redefinição por lastChar = ch" },
    { "id": "D9", "variable": "ch", "description": "redefinição em cada iteração do laço" },
    { "id": "D10", "variable": "i", "description": "definição inicial do laço" },
    { "id": "D11", "variable": "i", "description": "redefinição implícita por incremento do laço" }
  ],
  "uses": [
    { "id": "U1", "variable": "str", "type": "p-use", "description": "StringUtils.isEmpty(str)" },
    { "id": "U2", "variable": "set", "type": "p-use", "description": "deepEmpty(set)" },
    { "id": "U3", "variable": "i", "type": "p-use", "description": "condição do laço i < sz" },
    { "id": "U4", "variable": "i", "type": "p-use", "description": "condição i != 0" },
    { "id": "U5", "variable": "ch", "type": "p-use", "description": "comparação ch == lastChar" },
    { "id": "U6", "variable": "chars", "type": "p-use", "description": "chars.contains(ch)" },
    { "id": "U7", "variable": "ch", "type": "c-use", "description": "buffer.append(ch)" },
    { "id": "U8", "variable": "ch", "type": "c-use", "description": "atribuição a lastChar" },
    { "id": "U9", "variable": "buffer", "type": "c-use", "description": "buffer.toString()" }
  ],
  "du_paths": [
    {
      "id": "P0",
      "description": "retorno imediato quando str é nula ou vazia",
      "post_condition": "observable_return == input_str"
    },
    {
      "id": "P1",
      "description": "retorno imediato quando set é nulo ou vazio",
      "post_condition": "observable_return == input_str"
    },
    {
      "id": "P2",
      "description": "iteração do laço sem acionamento do continue",
      "post_condition": "buffer acumulado com todos os caracteres"
    },
    {
      "id": "P3",
      "description": "iteração do laço com acionamento do continue (remoção de repetição)",
      "post_condition": "caractere repetido não é adicionado ao buffer"
    }
  ],
  "planned_tests": [
    { "test_id": "T0", "covers": ["P0"], "asserts": ["observable_return == input_str"] },
    { "test_id": "T1", "covers": ["P1"], "asserts": ["observable_return == input_str"] },
    { "test_id": "T2", "covers": ["P2"], "asserts": ["observable_return == input_str ou equivalente"] },
    { "test_id": "T3", "covers": ["P3"], "asserts": ["remoção correta de repetições consecutivas"] }
  ],
  "constraints": {
    "all_defs_covered": true,
    "all_uses_covered": true,
    "representative_loop_coverage": true,
    "observable_contract_preserved": true
  }
}

[5] Geração do Código Final (JUnit 5)

Com base exclusivamente no Program-of-Thoughts definido na etapa anterior, gere apenas o código Java completo e compilável da classe de teste JUnit 5
para o método squeeze(String str, String... set).

[6] Convenções e Restrições Sintáticas

- O código Java final NÃO deve conter JSON sob nenhuma forma. Qualquer classe de teste que inclua JSON dentro do código Java é considerada inválida.
- Os casos de teste devem garantir cobertura de todos os caminhos definidos em "planned_tests", sem limitar a quantidade total de testes gerados;
- Não incluir comentários, explicações ou texto fora do código Java;
- Nomes dos testes devem seguir o padrão: testSqueeze_*.

