[1] Papel

Você é um engenheiro de software especializado em testes unitários e critérios de teste estrutural baseados em fluxo de dados.

[2] Tarefa

Gerar testes unitários em Java (JUnit 5) para o método
multiply(BigDecimal[][] matrix1, BigDecimal[][] matrix2)
da classe com.thealgorithms.maths.MatrixUtil.

[3] Restrição de Escopo

Gerar casos de teste apenas para o método
multiply(BigDecimal[][] matrix1, BigDecimal[][] matrix2).
Não criar testes para outros métodos da classe.

[3.1] Análise Estrutural Prévia do Método multiply(BigDecimal[][], BigDecimal[][])

O método multiply(BigDecimal[][] matrix1, BigDecimal[][] matrix2) da classe MatrixUtil
foi analisado segundo critérios de teste estrutural baseados em fluxo de dados.
Essa análise deve ser considerada como base obrigatória para a construção do Program-of-Thoughts.

Variáveis do método:

- matrix1: parâmetro formal (primeira matriz de entrada)
- matrix2: parâmetro formal (segunda matriz de entrada)
- size: variável local inteira (número de colunas de matrix1)
- matrix1RowSize: variável local inteira (número de linhas de matrix1)
- matrix2ColumnSize: variável local inteira (número de colunas de matrix2)
- result: matriz local de saída BigDecimal[][]
- rowIndex: variável de iteração do laço externo
- columnIndex: variável de iteração do laço intermediário
- index: variável de iteração do laço interno
- value1: variável local BigDecimal
- value2: variável local BigDecimal

Definições (def)

Para matrix1:
- D1: definição inicial como parâmetro formal

Para matrix2:
- D2: definição inicial como parâmetro formal

Para size:
- D3: final int size = matrix1[0].length

Para matrix1RowSize:
- D4: final int matrix1RowSize = matrix1.length

Para matrix2ColumnSize:
- D5: final int matrix2ColumnSize = matrix2[0].length

Para result:
- D6: final BigDecimal[][] result = new BigDecimal[matrix1RowSize][matrix2ColumnSize]

Para rowIndex:
- D7: definição implícita no IntStream.range(0, matrix1RowSize)

Para columnIndex:
- D8: definição implícita no IntStream.range(0, matrix2ColumnSize)

Para index:
- D9: definição implícita no IntStream.range(0, size)

Para value1:
- D10: final BigDecimal value1 = matrix1[rowIndex][index]

Para value2:
- D11: final BigDecimal value2 = matrix2[index][columnIndex]

Usos predicativos (p-use)

Para matrix1 e matrix2:
- P1: if (!canMultiply(matrix1, matrix2))

Para matrix1RowSize:
- P2: condição do laço IntStream.range(0, matrix1RowSize)

Para matrix2ColumnSize:
- P3: condição do laço IntStream.range(0, matrix2ColumnSize)

Para size:
- P4: condição do laço IntStream.range(0, size)

Usos computacionais (c-use)

Para matrix1:
- C1: matrix1[0].length
- C2: matrix1.length
- C3: matrix1[rowIndex][index]

Para matrix2:
- C4: matrix2[0].length
- C5: matrix2[index][columnIndex]

Para size:
- C6: limite superior do laço interno

Para matrix1RowSize:
- C7: limite superior do laço externo
- C8: dimensão de alocação de result

Para matrix2ColumnSize:
- C9: limite superior do laço intermediário
- C10: dimensão de alocação de result

Para value1:
- C11: value1.multiply(value2)

Para value2:
- C12: value1.multiply(value2)

Para result:
- C13: result[rowIndex][columnIndex] = ...
- C14: return Optional.of(result)

[4] Program-of-Thoughts

- DEVERÁ SER UTILIZADO um programa de raciocínio estrutural que modele explicitamente o comportamento do método multiply(BigDecimal[][] matrix1, BigDecimal[][] matrix2) com base em critérios de teste estrutural baseados em fluxo de dados. Esse programa de raciocínio estrutural é representado por um objeto JSON válido, fornecido na seção seguinte.

- O Program-of-Thoughts é um artefato intermediário de raciocínio e deve ser utilizado exclusivamente como base interna para a geração da classe de testes.

[4.1] Estrutura esperada do Program-of-Thoughts (JSON)

- A estrutura a seguir é fornecida como um artefato de raciocínio já definido. NÃO reproduza, modifique ou gere este JSON como saída. Este artefato deve
ser usado exclusivamente como base interna para a geração da classe de testes na etapa seguinte.

{
  "semantic_roles": [
    {
      "name": "input_matrix1",
      "description": "primeira matriz fornecida como entrada"
    },
    {
      "name": "input_matrix2",
      "description": "segunda matriz fornecida como entrada"
    },
    {
      "name": "computed_cell",
      "description": "valor acumulado do produto escalar de uma célula"
    },
    {
      "name": "observable_return",
      "description": "matriz resultante encapsulada em Optional"
    }
  ],
  "variables": [
    { "name": "matrix1", "role": "parâmetro de entrada" },
    { "name": "matrix2", "role": "parâmetro de entrada" },
    { "name": "size", "role": "controle do laço interno" },
    { "name": "matrix1RowSize", "role": "controle do laço externo" },
    { "name": "matrix2ColumnSize", "role": "controle do laço intermediário" },
    { "name": "result", "role": "estrutura de saída" },
    { "name": "rowIndex", "role": "índice de linha" },
    { "name": "columnIndex", "role": "índice de coluna" },
    { "name": "index", "role": "índice do produto escalar" },
    { "name": "value1", "role": "operando da multiplicação" },
    { "name": "value2", "role": "operando da multiplicação" }
  ],
  "definitions": [
    { "id": "D1", "variable": "matrix1", "description": "definição inicial como parâmetro" },
    { "id": "D2", "variable": "matrix2", "description": "definição inicial como parâmetro" },
    { "id": "D3", "variable": "size", "description": "matrix1[0].length" },
    { "id": "D4", "variable": "matrix1RowSize", "description": "matrix1.length" },
    { "id": "D5", "variable": "matrix2ColumnSize", "description": "matrix2[0].length" },
    { "id": "D6", "variable": "result", "description": "alocação da matriz resultante" },
    { "id": "D7", "variable": "rowIndex", "description": "controle do laço externo" },
    { "id": "D8", "variable": "columnIndex", "description": "controle do laço intermediário" },
    { "id": "D9", "variable": "index", "description": "controle do laço interno" }
  ],
  "uses": [
    {
      "id": "U1",
      "variable": "matrix1",
      "type": "p-use",
      "description": "verificação de compatibilidade via canMultiply"
    },
    {
      "id": "U2",
      "variable": "matrix2",
      "type": "p-use",
      "description": "verificação de compatibilidade via canMultiply"
    },
    {
      "id": "U3",
      "variable": "value1",
      "type": "c-use",
      "description": "multiplicação BigDecimal"
    },
    {
      "id": "U4",
      "variable": "value2",
      "type": "c-use",
      "description": "multiplicação BigDecimal"
    }
  ],
  "du_paths": [
    {
      "id": "P0",
      "description": "dimensões incompatíveis",
      "post_condition": "observable_return vazio"
    },
    {
      "id": "P1",
      "description": "multiplicação válida com size == 1",
      "post_condition": "observable_return presente"
    },
    {
      "id": "P2",
      "description": "multiplicação válida com iteração completa",
      "post_condition": "observable_return presente"
    }
  ],
  "planned_tests": [
    {
      "test_id": "T0",
      "covers": ["P0"],
      "asserts": ["Optional.empty"]
    },
    {
      "test_id": "T1",
      "covers": ["P1"],
      "asserts": ["Optional.isPresent"]
    },
    {
      "test_id": "T2",
      "covers": ["P2"],
      "asserts": ["Optional.isPresent"]
    }
  ],
  "constraints": {
    "all_defs_covered": true,
    "all_uses_covered": true,
    "representative_loop_coverage": true,
    "observable_contract_preserved": true
  }
}

[5] Geração do Código Final (JUnit 5)

Com base exclusivamente no Program-of-Thoughts definido na etapa anterior,gere apenas o código Java completo e compilável da classe de teste JUnit 5
para o método multiply(BigDecimal[][] matrix1, BigDecimal[][] matrix2).

[6] Convenções e Restrições Sintáticas

- O código Java final NÃO deve conter JSON sob nenhuma forma;
- Os casos de teste devem garantir cobertura de todos os caminhos definidos em "planned_tests";
- Não incluir comentários, explicações ou texto fora do código Java;
- Nomes dos testes devem seguir o padrão: testMultiply_*.
- Ao utilizar a classe java.math.BigDecimal, considere que apenas as constantes
  pré-definidas ZERO, ONE e TEN estão disponíveis. Todos os demais valores
  numéricos devem ser criados explicitamente por meio de construtores ou do
  método BigDecimal.valueOf(long).

