[1] Papel

Você é um engenheiro de software especializado em testes unitários e critérios de teste estrutural baseados em fluxo de dados.

[2] Tarefa

Gerar testes unitários em Java (JUnit 5) para o método elementCompareTo(T element)
da classe org.apache.commons.lang3.Range.

[3] Restrição de Escopo

Gerar casos de teste apenas para o método elementCompareTo(T element).
Não criar testes para outros métodos da classe.

[3.1] Análise Estrutural Prévia do Método elementCompareTo(T element)

O método elementCompareTo(T element) da classe Range foi analisado segundo
critérios de teste estrutural baseados em fluxo de dados.
Essa análise deve ser considerada como base obrigatória para a construção do
Program-of-Thoughts e do Chain-of-Code.

Variáveis do método:

- element: parâmetro formal (elemento a ser comparado)

Definições (def)

Para element:
- D1: definição inicial como parâmetro formal do método

Usos predicativos (p-use)

Para element:
- P1: decisão condicional de validação de entrada (element == null)
- P2: decisão condicional baseada no resultado de isAfter(element)
- P3: decisão condicional baseada no resultado de isBefore(element)

Usos computacionais (c-use)

- Nenhum

[4] Program-of-Thoughts

- DEVERÁ SER UTILIZADO um programa de raciocínio estrutural que modele explicitamente o comportamento do método elementCompareTo(T element) com base em critérios de teste estrutural baseados em fluxo de dados. Esse programa de raciocínio estrutural é representado por um objeto JSON válido, fornecido na seção seguinte.

- O Program-of-Thoughts é um artefato intermediário de raciocínio e deve ser utilizado exclusivamente como base interna para a geração da classe de testes.

[4.1] Estrutura esperada do Program-of-Thoughts (JSON)

- A estrutura a seguir é fornecida como um artefato de raciocínio já definido. NÃO reproduza, modifique ou gere este JSON como saída. Este artefato deve ser usado exclusivamente como base interna para a geração da classe de testes na etapa seguinte.

{
  "semantic_roles": [
    {
      "name": "input_element",
      "description": "elemento fornecido como entrada ao método elementCompareTo"
    },
    {
      "name": "observable_return",
      "description": "valor inteiro retornado por elementCompareTo(input_element)"
    }
  ],
  "variables": [
    { "name": "element", "role": "parâmetro formal de entrada" }
  ],
  "definitions": [
    { "id": "D1", "variable": "element", "description": "definição inicial como parâmetro formal" }
  ],
  "uses": [
    {
      "id": "U1",
      "variable": "element",
      "type": "p-use",
      "description": "verificação de entrada nula (element == null)"
    },
    {
      "id": "U2",
      "variable": "element",
      "type": "p-use",
      "description": "decisão baseada no resultado de isAfter(element)"
    },
    {
      "id": "U3",
      "variable": "element",
      "type": "p-use",
      "description": "decisão baseada no resultado de isBefore(element)"
    }
  ],
  "du_paths": [
    {
      "id": "P0",
      "description": "element é nulo",
      "post_condition": "lançamento de NullPointerException"
    },
    {
      "id": "P1",
      "description": "element ocorre antes do intervalo",
      "post_condition": "retorno -1"
    },
    {
      "id": "P2",
      "description": "element ocorre após o intervalo",
      "post_condition": "retorno 1"
    },
    {
      "id": "P3",
      "description": "element ocorre dentro do intervalo",
      "post_condition": "retorno 0"
    }
  ],
  "planned_tests": [
    {
      "test_id": "T0",
      "covers": ["P0"],
      "asserts": ["NullPointerException lançada"]
    },
    {
      "test_id": "T1",
      "covers": ["P1"],
      "asserts": ["valor retornado == -1"]
    },
    {
      "test_id": "T2",
      "covers": ["P2"],
      "asserts": ["valor retornado == 1"]
    },
    {
      "test_id": "T3",
      "covers": ["P3"],
      "asserts": ["valor retornado == 0"]
    }
  ],
  "constraints": {
    "all_defs_covered": true,
    "all_p_uses_covered": true,
    "all_decision_outcomes_covered": true,
    "observable_contract_preserved": true
  }
}

[5] Geração do Código Final (JUnit 5)

Com base exclusivamente no Program-of-Thoughts definido na etapa anterior,
gere apenas o código Java completo e compilável da classe de teste JUnit 5
para o método elementCompareTo(T element).

[6] Convenções e Restrições Sintáticas

- O código Java final NÃO deve conter JSON sob nenhuma forma. 
- Qualquer classe de teste que inclua JSON dentro do código Java é considerada inválida.
- Os casos de teste devem garantir cobertura de todos os caminhos definidos em "planned_tests", sem limitar a quantidade total de testes gerados;
- Não incluir comentários, explicações ou texto fora do código Java.
- Nomes dos testes devem seguir o padrão: testElementCompareTo_*.

