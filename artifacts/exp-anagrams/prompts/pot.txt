[1] Papel
Você é um engenheiro de software especializado em testes unitários e critérios
de teste estrutural baseados em fluxo de dados.

[2] Tarefa
Gerar testes unitários em Java (JUnit 5) para o método approach2(String a, String b).

[3] Conformidade dos nomes dos casos de testes
Todos os casos de teste devem ter nomes que façam referência explícita
ao método approach2, como por exemplo: testApproach2_*.

[3.1] Análise Estrutural Prévia do Método approach2(String a, String b)

O método approach2(String a, String b) da classe Anagrams foi previamente analisado
segundo critérios de teste estrutural baseados em fluxo de dados.

Variáveis do método:
- a: parâmetro formal (primeira string de entrada)
- b: parâmetro formal (segunda string de entrada)
- m: array local de inteiros (frequência dos caracteres de a)
- n: array local de inteiros (frequência dos caracteres de b)
- c: variável de iteração em laços foreach
- i: variável de controle do laço for

Definições (def)

Para a:
- D1: definição inicial como parâmetro formal

Para b:
- D2: definição inicial como parâmetro formal

Para m:
- D3: definição por alocação (new int[26])
- D4: redefinições por incremento m[c - 'a']++

Para n:
- D5: definição por alocação (new int[26])
- D6: redefinições por incremento n[c - 'a']++

Para c:
- D7: definição como variável de iteração no laço foreach sobre a
- D8: definição como variável de iteração no laço foreach sobre b

Para i:
- D9: definição como variável de controle do laço for (int i = 0)

Usos predicativos (p-use)

Para a e b:
- P1: if (a.length() != b.length())

Para i:
- P2: condição do laço for (i < 26)

Para m e n:
- P3: if (m[i] != n[i])

Usos computacionais (c-use)

Para a:
- C1: uso em a.length()
- C2: uso em a.toCharArray()

Para b:
- C3: uso em b.length()
- C4: uso em b.toCharArray()

Para m:
- C5: acesso m[c - 'a']
- C6: incremento m[c - 'a']++
- C7: acesso m[i]

Para n:
- C8: acesso n[c - 'a']
- C9: incremento n[c - 'a']++
- C10: acesso n[i]

Para c:
- C11: uso em expressão c - 'a'

Para i:
- C12: uso como índice em m[i] e n[i]
- C13: incremento i++

[4] Program-of-Thoughts (Plano Estrutural)

Antes de gerar o código final dos testes, produza um programa de
raciocínio estrutural que modele explicitamente o comportamento do
método approach2(String a, String b) com base em critérios de fluxo de dados.

Esse programa de pensamentos deve ser representado exclusivamente
por um objeto JSON válido.

O JSON deve capturar:
- variáveis relevantes do método;
- definições de variáveis (All-Defs);
- usos computacionais (c-use) e predicativos (p-use);
- pares definição–uso (All-Uses);
- caminhos definição–uso relevantes (DU-Paths);
- mapeamento explícito entre caminhos e casos de teste planejados.

Nesta etapa:
- Gere exclusivamente um objeto JSON válido como saída da resposta do modelo;
- O JSON é um artefato intermediário de raciocínio e NÃO faz parte da classe de testes;
- NÃO escreva texto explicativo fora do JSON;
- O código JSON dentro da classe de teste deve ser comentado com //;
- NÃO gere ainda os casos de teste.

[4.1] Estrutura esperada do Program-of-Thoughts (JSON)

{
  "variables": [
    { "name": "a", "role": "parâmetro" },
    { "name": "b", "role": "parâmetro" },
    { "name": "m", "role": "array de frequência de a" },
    { "name": "n", "role": "array de frequência de b" },
    { "name": "c", "role": "variável de iteração" },
    { "name": "i", "role": "controle de laço" }
  ],
  "definitions": [
    { "id": "D1", "variable": "a", "description": "definição como parâmetro formal" },
    { "id": "D2", "variable": "b", "description": "definição como parâmetro formal" },
    { "id": "D3", "variable": "m", "description": "alocação new int[26]" },
    { "id": "D4", "variable": "m", "description": "incrementos m[c - 'a']++" },
    { "id": "D5", "variable": "n", "description": "alocação new int[26]" },
    { "id": "D6", "variable": "n", "description": "incrementos n[c - 'a']++" },
    { "id": "D7", "variable": "c", "description": "iteração sobre a" },
    { "id": "D8", "variable": "c", "description": "iteração sobre b" },
    { "id": "D9", "variable": "i", "description": "controle do laço for" }
  ],
  "uses": [
    { "id": "U1", "variable": "a,b", "type": "p-use", "description": "a.length() != b.length()" },
    { "id": "U2", "variable": "a", "type": "c-use", "description": "a.length(), a.toCharArray()" },
    { "id": "U3", "variable": "b", "type": "c-use", "description": "b.length(), b.toCharArray()" },
    { "id": "U4", "variable": "m", "type": "c-use", "description": "m[c - 'a'], m[i]" },
    { "id": "U5", "variable": "n", "type": "c-use", "description": "n[c - 'a'], n[i]" },
    { "id": "U6", "variable": "i", "type": "p-use", "description": "i < 26" },
    { "id": "U7", "variable": "m,n", "type": "p-use", "description": "m[i] != n[i]" }
  ],
  "du_paths": [
    { "id": "P1", "description": "retorno imediato por tamanhos diferentes" },
    { "id": "P2", "description": "tamanhos iguais, frequências coincidem em todas as posições" },
    { "id": "P3", "description": "tamanhos iguais, divergência em ao menos uma posição do array" }
  ],
  "planned_tests": [
    { "test_id": "T1", "covers": ["P1"] },
    { "test_id": "T2", "covers": ["P2"] },
    { "test_id": "T3", "covers": ["P3"] }
  ],
  "constraints": {
    "no_intermediate_redefinition": true,
    "all_defs_covered": true,
    "all_uses_covered": true,
    "complete_loop_evaluation": true
  }
}

[5] Geração do Código Final (JUnit 5)

Com base exclusivamente no Program-of-Thoughts definido na etapa anterior,
gere apenas o código Java completo e compilável da classe de teste JUnit 5
para o método approach2(String a, String b).

Requisitos:
- Cada método de teste deve corresponder a um item de "planned_tests";
- Não inclua comentários, explicações ou texto fora do código Java.

