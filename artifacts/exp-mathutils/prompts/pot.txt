[1] Papel

Você é um engenheiro de software especializado em testes unitários e critérios de teste estrutural baseados em fluxo de dados.

[2] Tarefa

Gerar testes unitários em Java (JUnit 5) para o método
public static void checkFinite(double[] val)
da classe org.apache.commons.math3.util.MathUtils.

[3] Restrição de Escopo

Gerar casos de teste apenas para o método
public static void checkFinite(double[] val).
Não criar testes para outros métodos da classe.

[3.1] Análise Estrutural Prévia do Método public static void checkFinite(double[] val)

O método checkFinite(double[] val) da classe MathUtils foi analisado segundo critérios de teste estrutural baseados em fluxo de dados, considerando exclusivamente o código do método fornecido. Essa análise deve ser considerada como base obrigatória para a construção do Program-of-Thoughts.

Variáveis do método:

- val: parâmetro formal (array de valores double)
- i: variável de controle do laço
- x: variável local (elemento atual do array)

Definições (def)

Para val:
- D1: definição inicial como parâmetro formal do método

Para i:
- D2: definição inicial no laço for (i = 0)
- D3: redefinição no incremento do laço (i++)

Para x:
- D4: definição como leitura do elemento do array (x = val[i])

Usos predicativos (p-use)

Para i:
- P1: condição do laço (i < val.length)

Para x:
- P2: decisão condicional composta (Double.isInfinite(x) || Double.isNaN(x))

Usos computacionais (c-use)

- C1: uso de val no lado direito da atribuição (x = val[i])
- C2: uso de x como argumento na construção da exceção NotFiniteNumberException
- C3: uso de i como argumento na construção da exceção NotFiniteNumberException

[4] Program-of-Thoughts

- DEVERÁ SER UTILIZADO um programa de raciocínio estrutural que modele explicitamente o comportamento do método public static void checkFinite(double[] val) com base em critérios de teste estrutural baseados em fluxo de dados.
- Esse programa de raciocínio estrutural é representado por um objeto JSON válido,fornecido na seção seguinte.
- O Program-of-Thoughts é um artefato intermediário de raciocínio e deve ser utilizado exclusivamente como base interna para a geração da classe de testes.

[4.1] Estrutura esperada do Program-of-Thoughts (JSON)

- A estrutura a seguir é fornecida como um artefato de raciocínio já definido.
- NÃO reproduza, modifique ou gere este JSON como saída.
- Este artefato deve ser usado exclusivamente como base interna para a geração da classe de testes na etapa seguinte.

{
  "semantic_roles": [
    {
      "name": "input_array",
      "description": "array de valores double fornecido como entrada ao método checkFinite"
    },
    {
      "name": "observable_effect",
      "description": "execução normal sem exceção ou lançamento de NotFiniteNumberException"
    }
  ],
  "variables": [
    { "name": "val", "role": "parâmetro formal de entrada" },
    { "name": "i", "role": "variável de controle do laço" },
    { "name": "x", "role": "variável local de leitura do array" }
  ],
  "definitions": [
    {
      "id": "D1",
      "variable": "val",
      "description": "definição inicial como parâmetro formal"
    },
    {
      "id": "D2",
      "variable": "i",
      "description": "definição inicial no laço for"
    },
    {
      "id": "D4",
      "variable": "x",
      "description": "definição como leitura do elemento do array"
    }
  ],
  "uses": [
    {
      "id": "U1",
      "variable": "i",
      "type": "p-use",
      "description": "condição de continuidade do laço (i < val.length)"
    },
    {
      "id": "U2",
      "variable": "x",
      "type": "p-use",
      "description": "decisão condicional composta (Double.isInfinite(x) || Double.isNaN(x))"
    },
    {
      "id": "U3",
      "variable": "x",
      "type": "c-use",
      "description": "uso como argumento na construção da exceção NotFiniteNumberException"
    },
    {
      "id": "U4",
      "variable": "i",
      "type": "c-use",
      "description": "uso como argumento na construção da exceção NotFiniteNumberException"
    }
  ],
  "du_paths": [
    {
      "id": "P0",
      "description": "array contendo valor NaN",
      "post_condition": "lançamento de NotFiniteNumberException"
    },
    {
      "id": "P1",
      "description": "array contendo valor infinito",
      "post_condition": "lançamento de NotFiniteNumberException"
    },
    {
      "id": "P2",
      "description": "array contendo apenas valores finitos",
      "post_condition": "execução normal sem exceção"
    }
  ],
  "planned_tests": [
    {
      "test_id": "T0",
      "covers": ["P0"],
      "asserts": ["NotFiniteNumberException lançada"]
    },
    {
      "test_id": "T1",
      "covers": ["P1"],
      "asserts": ["NotFiniteNumberException lançada"]
    },
    {
      "test_id": "T2",
      "covers": ["P2"],
      "asserts": ["nenhuma exceção lançada"]
    }
  ],
  "constraints": {
    "all_defs_covered": true,
    "all_p_uses_covered": true,
    "all_c_uses_covered": true,
    "all_decision_outcomes_covered": true,
    "observable_contract_preserved": true
  }
}

[5] Geração do Código Final (JUnit 5)

Com base exclusivamente no Program-of-Thoughts definido na etapa anterior,gere como resultado final o código Java completo, compilável e executável
da classe de teste JUnit 5 para o método public static void checkFinite(double[] val).

[6] Convenções e Restrições Sintáticas

- O código Java final NÃO deve conter JSON sob nenhuma forma;
- Qualquer classe de teste que inclua JSON dentro do código Java é considerada inválida;
- Os casos de teste devem garantir cobertura de todos os caminhos definidos em "planned_tests";
- Não incluir comentários, explicações ou texto fora do código Java;
- Nomes dos testes devem seguir o padrão: testCheckFinite_*.

