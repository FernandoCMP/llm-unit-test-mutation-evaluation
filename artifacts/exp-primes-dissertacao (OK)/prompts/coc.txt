[1] Papel

Você é um engenheiro de software especializado em testes unitários e critérios de teste estrutural baseados em fluxo de dados.

[2] Tarefa

Gerar testes unitários em Java (JUnit 5) para o método nextPrime(int n).
Não gerar testes para outros métodos da classe.

[3] Restrição de Escopo

Gerar casos de teste apenas para o método nextPrime(int n).
Não criar testes para outros métodos da classe.

[3.1] Análise Estrutural Prévia do Método nextPrime(int n)

O método nextPrime(int n) da classe Primes foi previamente analisado segundo critérios de teste estrutural baseados em fluxo de dados.
Essa análise deve ser considerada como base obrigatória para a construção do Chain of Code.

Variáveis do método (linhas 74–109):
- n: parâmetro formal e variável redefinida
- rem: variável local final

Definições (def)

Para n:
- linha 74: definição inicial do parâmetro n
- linha 81: n = n | 1
- linha 94: n += 2
- linha 97: n += 4
- linha 103: n += 2
- linha 107: n += 4

Para rem:
- linha 92: final int rem = n % 3

Usos predicativos (p-use)

Para n:
- linha 75: if (n < 0)
- linha 78: if (n == 2)
- linha 82: if (n == 1)
- linha 86: if (isPrime(n))            [antes do laço]
- linha 100: if (isPrime(n))           [entrada do laço]
- linha 104: if (isPrime(n))           [após n += 2 no laço]

Para rem:
- linha 93: if (0 == rem)
- linha 95: else if (1 == rem)

Usos computacionais (c-use)

Para n:
- linha 76: uso de n no lançamento da exceção
- linha 81: operação bitwise n = n | 1
- linha 87: return n
- linha 92: rem = n % 3
- linha 94: n += 2
- linha 97: n += 4
- linha 101: return n
- linha 103: n += 2
- linha 105: return n
- linha 107: n += 4

[4] Chain of Code

Questão:
Como o método nextPrime(int n) se comporta para diferentes valores de entrada?

Convenções:
- input_n: valor original fornecido ao método nextPrime;
- return_candidate: valor elegível ao retorno em um caminho;
- observable_return: valor efetivamente retornado por nextPrime(input_n);
- def(Di): definição identificada conforme a análise estrutural;
- p_use: uso predicativo;
- c_use: uso computacional;
- path(Pi): caminho definição–uso livre de redefinição.
- delta_state: representação explícita do estado semântico observável do método após uma ação relevante, indicando mudanças em variáveis, candidatos a retorno, efeitos de exceção ou conclusão de artefatos.Deve registrar apenas informações relevantes para derivação de cenários de teste, como: redefinição de variáveis, definição de return_candidate, observable_return indefinido/definido ou finalização do conjunto de cenários de teste.

Modelo do Chain of Code:

1   input_n = original_input
    def(D1): n = input_n
    delta_state: { n definido }

2   p_use: (n < 0)
    path(P0)
    c_use: throw_exception(n)
    delta_state: { observable_return indefinido }

3   p_use: (n == 2)
    path(P1)
    c_use: return n
    delta_state: { return_candidate = 2 }

4   def(D2): n = n | 1
    c_use: operação bitwise
    delta_state: { n redefinido }

5   p_use: (n == 1)
    path(P2)
    c_use: return n
    delta_state: { return_candidate = 2 }

6   p_use: isPrime(n) [linha 86]
    path(P3)
    c_use: return n
    delta_state: { return_candidate = n }

7   def(D7): rem = n % 3
    c_use: cálculo de rem
    delta_state: { rem definido }

8   p_use: (rem == 0)
    def(D3): n = n + 2
    path(P4)
    delta_state: { n redefinido }

9   p_use: (rem == 1)
    def(D4): n = n + 4
    path(P5)
    delta_state: { n redefinido }

10  p_use: isPrime(n) [linha 100 – entrada do laço]
    path(P6)
    c_use: return n
    delta_state: { return_candidate = n }

11  def(D5): n = n + 2
    p_use: isPrime(n) [linha 104 – após incremento]
    path(P7)
    c_use: return n
    delta_state: { return_candidate = n }

12  def(D6): n = n + 4
    path(P8)
    delta_state: { n redefinido e volta ao p_use da linha 100 não considerada }

13  unit_test_scenarios = derive_from_paths(
        P0, P1, P2, P3, P4, P5, P6, P7
    )
    delta_state: { unit_test_scenarios = complete }

14  observable_return = nextPrime(input_n)
    delta_state: { observable_return = return_candidate }

Resposta:unit_test_scenarios

[5] Geração do Código Final (JUnit 5)

Com base exclusivamente no Modelo do Chain of Code definido acima, gere apenas o código Java completo e compilável da classe de teste JUnit 5
para o método nextPrime(int n).

[6] Requisitos

- Os casos de teste devem garantir cobertura de todos os caminhos definidos no Chain of Code;
- Não incluir comentários, explicações ou texto fora do código Java;
- Os nomes dos testes devem seguir o padrão: testNextPrime_*.
