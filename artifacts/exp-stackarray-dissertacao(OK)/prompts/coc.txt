[1] Papel

Você é um engenheiro de software especializado em testes unitários e critérios de teste estrutural baseados em fluxo de dados.

[2] Tarefa

Gerar testes unitários em Java (JUnit 5) para o método pop().
Não gerar testes para outros métodos da classe.

[3] Restrição de Escopo

Gerar casos de teste apenas para o método pop().
Não criar testes para outros métodos da classe.

[3.1] Análise Estrutural Prévia do Método pop()

O método pop() da classe StackArray foi previamente analisado
segundo critérios de teste estrutural baseados em fluxo de dados.

Variáveis do método:
- top: variável de estado da pilha (controle do índice do topo)
- stackArray: array interno que armazena os elementos da pilha
- maxSize: capacidade atual da pilha

Definições (def)

Para top:
- D1: redefinição por pós-decremento no retorno (top--)
- D2: redefinição indireta após chamada de resize seguida de pop()

Para stackArray:
- D3: redefinição indireta por resize(int)

Para maxSize:
- D4: redefinição indireta por resize(int)

Usos predicativos (p-use)

Para top:
- P1: if (!isEmpty())              [condição equivalente a top != -1]
- P2: if (top < maxSize / 4)

Para maxSize:
- P3: uso em expressão de decisão (top < maxSize / 4)

Usos computacionais (c-use)

Para top:
- C1: uso como índice em stackArray[top]
- C2: uso em pós-decremento (top--)
- C3: uso em expressão aritmética (top < maxSize / 4)

Para stackArray:
- C4: acesso ao elemento stackArray[top]
- C5: retorno do valor armazenado no topo

Para maxSize:
- C6: uso em cálculo aritmético (maxSize / 4)
- C7: uso como argumento em resize(maxSize / 2)

[4] Chain of Code

Questão:
Como o método pop() se comporta sob diferentes estados internos da pilha?

Convenções:
- initial_state: estado inicial do objeto StackArray antes da chamada de pop()
- return_candidate: valor elegível ao retorno em um caminho
- observable_return: valor efetivamente retornado por pop()
- def(Di): definição identificada conforme a análise estrutural
- p_use: uso predicativo
- c_use: uso computacional
- path(Pi): caminho definição–uso livre de redefinição
- delta_state: representação explícita do estado semântico observável do método após uma ação relevante,
  indicando mudanças em variáveis, candidatos a retorno ou conclusão da derivação de cenários de teste.

Modelo do Chain of Code:

1   initial_state = StackArray(top, stackArray, maxSize)
    delta_state: { estado inicial definido }

2   p_use(P1): if (!isEmpty()) == true
    path(P1)
    c_use(C1): uso de top como índice em stackArray[top]
    c_use(C4): acesso ao elemento stackArray[top]
    c_use(C2): top--
    def(D1): top redefinido
    c_use(C5): retorno do valor armazenado no topo
    delta_state: { return_candidate definido, top decrementado }

3   observable_return = return_candidate
    delta_state: { observable_return definido }

4   p_use(P1): if (!isEmpty()) == false
    path(P1_false)
    delta_state: { pilha vazia }

5   p_use(P2, P3): (top < maxSize / 4) == true
    path(P2_true)
    c_use(C3): uso de top em expressão aritmética
    c_use(C6): cálculo maxSize / 4
    c_use(C7): resize(maxSize / 2)
    def(D3): stackArray redefinido
    def(D4): maxSize redefinido
    delta_state: { capacidade da pilha reduzida }

6   c_use: chamada recursiva pop()
    def(D2): redefinição indireta de top
    delta_state: { retorno obtido por chamada recursiva }

7   observable_return = return_candidate
    delta_state: { observable_return definido }

8   p_use(P2, P3): (top < maxSize / 4) == false
    path(P2_false)
    c_use: retorno constante
    delta_state: { return_candidate = -1 }

9   observable_return = return_candidate
    delta_state: { observable_return definido }

10  unit_test_scenarios = derive_from_paths(
        P1_true,
        P1_false ∧ P2_true,
        P1_false ∧ P2_false
    )
    delta_state: { unit_test_scenarios = complete }

Resposta: unit_test_scenarios

[5] Geração do Código Final (JUnit 5)

Com base exclusivamente no Modelo do Chain of Code definido acima,
gere apenas o código Java completo e compilável da classe de teste JUnit 5
para o método pop().

[6] Requisitos

- Os casos de teste devem garantir cobertura de todos os caminhos definidos no Chain of Code;
- Não incluir comentários, explicações ou texto fora do código Java;
- Os nomes dos testes devem seguir o padrão: testPop_*.

