[1] Papel

Você é um engenheiro de software especializado em testes unitários e critérios de teste estrutural
baseados em fluxo de dados.

[2] Tarefa

Gerar testes unitários em Java (JUnit 5) para o método encodeHex(byte[] data)
da classe org.apache.commons.codec.binary.Hex.

[3] Restrição de Escopo

Gerar casos de teste apenas para o método encodeHex(byte[] data).
Não criar testes para outros métodos da classe.

[3.1] Análise Estrutural Prévia do Método encodeHex(byte[] data)

O método encodeHex(byte[] data) da classe Hex foi previamente analisado
segundo critérios de teste estrutural baseados em fluxo de dados.
Essa análise deve ser considerada como base obrigatória para a construção do Chain of Code.

Variáveis do método encodeHex(byte[] data):

- data: parâmetro formal (array de bytes de entrada)
- l: variável local inteira (comprimento do array de entrada)
- out: variável local (array de caracteres de saída)
- i: variável de controle do laço
- j: variável de controle do índice de escrita no array out

Definições (def)

Para data:
- D1: definição inicial como parâmetro formal do método encodeHex(byte[] data)

Para l:
- D2: definição por leitura do comprimento do array (int l = data.length)

Para out:
- D3: definição por alocação do array de saída (char[] out = new char[l << 1])

Para i:
- D4: definição inicial no cabeçalho do laço (int i = 0)

Para j:
- D5: definição inicial no cabeçalho do laço (int j = 0)

Usos predicativos (p-use)

Para i:
- P1: condição do laço for (i < l)

Usos computacionais (c-use)

Para data:
- C1: uso computacional de data[i] nas operações bitwise

Para l:
- C2: uso computacional de l no cálculo do tamanho do array out (l << 1)
- C3: uso computacional de l na condição do laço (i < l)

Para out:
- C4: atribuição out[j] = DIGITS[(0xF0 & data[i]) >>> 4]
- C5: atribuição out[j] = DIGITS[0x0F & data[i]]

Para i:
- C6: incremento do índice do laço (i++)

Para j:
- C7: incremento j++ após escrita do primeiro nibble
- C8: incremento j++ após escrita do segundo nibble

[4] Chain of Code

Questão:Como o método encodeHex(byte[] data) se comporta para diferentes valores de entrada?

Convenções:
- input_data: array de bytes originalmente fornecido ao método encodeHex;
- return_candidate: array de caracteres elegível ao retorno em um caminho;
- observable_return: array de caracteres efetivamente retornado por
  encodeHex(input_data);
- def(Di): definição identificada conforme a análise estrutural;
- p_use: uso predicativo;
- c_use: uso computacional;
- path(Pi): caminho definição–uso livre de redefinição;
- delta_state: representação explícita do estado semântico observável do método
  após uma ação relevante, indicando mudanças em variáveis, candidatos a retorno
  ou conclusão de cenários de teste.

Modelo do Chain of Code:

1   input_data = original_input_data
    def(D1): data = input_data
    delta_state: { data definido }

2   def(D2): l = data.length
    delta_state: { l definido }

3   def(D3): out = new char[l << 1]
    delta_state: { return_candidate alocado }

4   def(D4): i = 0
    def(D5): j = 0
    delta_state: { i definido, j definido }

5   p_use: (i < l)
    path(P0)
    delta_state: { laço não executado }

6   c_use: data[i]
    c_use: out[j] = DIGITS[(0xF0 & data[i]) >>> 4]
    c_use: j++
    c_use: out[j] = DIGITS[0x0F & data[i]]
    c_use: j++
    c_use: i++
    path(P1)
    delta_state: { uma iteração do laço executada }

7   repetição do passo 6 enquanto p_use (i < l) for verdadeiro
    path(P2)
    delta_state: { múltiplas iterações do laço executadas }

8   observable_return = encodeHex(input_data)
    delta_state: { observable_return = return_candidate }

Resposta:unit_test_scenarios

[5] Geração do Código Final (JUnit 5)

Com base exclusivamente no Modelo do Chain of Code definido acima,
gere apenas o código Java completo e compilável da classe de teste JUnit 5
para o método encodeHex(byte[] data).

[6] Requisitos

- Os casos de teste devem garantir cobertura de todos os caminhos definidos no Chain of Code;
- Não incluir comentários, explicações ou texto fora do código Java;
- Os nomes dos testes devem seguir o padrão:testEncodeHex_*.

