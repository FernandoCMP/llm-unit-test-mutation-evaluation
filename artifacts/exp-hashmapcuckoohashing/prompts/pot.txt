[1] Papel

Você é um engenheiro de software especializado em testes unitários e critérios de teste estrutural baseados em fluxo de dados.

[2] Tarefa

Gerar testes unitários em Java (JUnit 5) para o método public void insertKey2HashTable(int key) da classe com.thealgorithms.datastructures.hashmap.hashing.HashMapCuckooHashing.

[3] Restrição de Escopo

Gerar casos de teste apenas para o método public void insertKey2HashTable(int key).
Não criar testes para outros métodos da classe.

[3.1] Análise Estrutural Prévia do Método public void insertKey2HashTable(int key)

O método insertKey2HashTable(int key) da classe HashMapCuckooHashing foi analisado segundo critérios de teste estrutural baseados em fluxo de dados, considerando exclusivamente o código do método fornecido.Essa análise deve ser considerada como base obrigatória para a construção do Program-of-Thoughts.

Variáveis do método:

- key: parâmetro formal (chave a ser inserida)
- wrappedInt: variável local (representação Integer da chave corrente)
- temp: variável local auxiliar para realocação
- hash: variável local inteira (índice calculado)
- loopCounter: variável local de controle do laço
- thresh: atributo da classe (limite máximo de iterações)
- size: atributo da classe (contador de chaves armazenadas)

Definições (def)

Para key:
- D1: definição inicial como parâmetro formal do método

Para wrappedInt:
- D2: definição como Integer.valueOf(key)
- D6: redefinição após realocação de chaves

Para loopCounter:
- D3: definição inicial como 0
- D4: redefinição a cada iteração do laço

Para hash:
- D5: definição como resultado de hashFunction1(key)
- D7: redefinição como resultado de hashFunction2(temp)

Para temp:
- D8: definição como valor previamente armazenado em buckets[hash]

Para size:
- D9: redefinição após inserção bem-sucedida da chave

Usos predicativos (p-use)

- P1: verificação se a tabela está cheia (isFull())
- P2: verificação de duplicidade da chave (checkTableContainsKey(key))
- P3: condição de continuação do laço (loopCounter <= thresh)
- P4: verificação de posição livre após hashFunction1
      (buckets[hash] == null || buckets[hash] == AVAILABLE)
- P5: verificação de posição livre após hashFunction2
      (buckets[hash] == null || buckets[hash] == AVAILABLE)

Usos computacionais (c-use)

- C1: uso de key no cálculo de hashFunction1
- C2: uso de wrappedInt/temp no cálculo de hashFunction2
- C3: uso de wrappedInt na escrita em buckets[hash]
- C4: uso de temp na realocação de chaves
- C5: uso de size na atualização do estado da tabela
- C6: chamada de checkLoadFactor() como efeito colateral após inserção

[4] Program-of-Thoughts

- DEVERÁ SER UTILIZADO um programa de raciocínio estrutural que modele explicitamente
o comportamento do método public void insertKey2HashTable(int key) com base em critérios
de teste estrutural baseados em fluxo de dados.
Esse programa de raciocínio estrutural é representado por um objeto JSON válido,
fornecido na seção seguinte.

- O Program-of-Thoughts é um artefato intermediário de raciocínio e deve ser utilizado
exclusivamente como base interna para a geração da classe de testes.

[4.1] Estrutura esperada do Program-of-Thoughts (JSON)

- A estrutura a seguir é fornecida como um artefato de raciocínio já definido.
NÃO reproduza, modifique ou gere este JSON como saída.
Este artefato deve ser usado exclusivamente como base interna
para a geração da classe de testes na etapa seguinte.

{
  "semantic_roles": [
    {
      "name": "input_key",
      "description": "chave fornecida como entrada ao método insertKey2HashTable"
    },
    {
      "name": "observable_effect",
      "description": "efeito observável no estado da tabela (inserção, realocação, rehash) ou exceção lançada"
    }
  ],

  "variables": [
    { "name": "key", "role": "parâmetro formal de entrada" },
    { "name": "wrappedInt", "role": "variável local que representa a chave corrente" },
    { "name": "temp", "role": "variável local auxiliar de realocação" },
    { "name": "hash", "role": "índice calculado no array de buckets" },
    { "name": "loopCounter", "role": "variável de controle do laço" },
    { "name": "thresh", "role": "limite máximo de iterações do laço" },
    { "name": "size", "role": "atributo que representa o número de chaves armazenadas" },
    { "name": "buckets", "role": "estrutura de armazenamento da tabela hash" },
    { "name": "AVAILABLE", "role": "valor sentinela para posição logicamente vazia" }
  ],

  "definitions": [
    {
      "id": "D1",
      "variable": "key",
      "description": "definição inicial como parâmetro formal"
    },
    {
      "id": "D2",
      "variable": "wrappedInt",
      "description": "definição inicial como Integer.valueOf(key)"
    },
    {
      "id": "D3",
      "variable": "loopCounter",
      "description": "definição inicial como 0"
    },
    {
      "id": "D4",
      "variable": "hash",
      "description": "definição como resultado de hashFunction1(key)"
    },
    {
      "id": "D5",
      "variable": "temp",
      "description": "definição como valor previamente armazenado em buckets[hash]"
    },
    {
      "id": "D6",
      "variable": "wrappedInt",
      "description": "redefinição após realocação de chave"
    },
    {
      "id": "D7",
      "variable": "hash",
      "description": "redefinição como resultado de hashFunction2(temp)"
    },
    {
      "id": "D8",
      "variable": "size",
      "description": "redefinição após inserção bem-sucedida da chave"
    }
  ],

  "uses": [
    {
      "id": "U1",
      "variable": "buckets",
      "type": "p-use",
      "description": "verificação de tabela cheia (isFull)"
    },
    {
      "id": "U2",
      "variable": "key",
      "type": "p-use",
      "description": "verificação de duplicidade da chave (checkTableContainsKey)"
    },
    {
      "id": "U3",
      "variable": "loopCounter",
      "type": "p-use",
      "description": "controle de iteração do laço (loopCounter <= thresh)"
    },
    {
      "id": "U4",
      "variable": "buckets",
      "type": "p-use",
      "description": "verificação de posição livre após hashFunction1 (null ou AVAILABLE)"
    },
    {
      "id": "U5",
      "variable": "buckets",
      "type": "p-use",
      "description": "verificação de posição livre após hashFunction2 (null ou AVAILABLE)"
    },
    {
      "id": "U6",
      "variable": "key",
      "type": "c-use",
      "description": "uso no cálculo de hashFunction1"
    },
    {
      "id": "U7",
      "variable": "wrappedInt",
      "type": "c-use",
      "description": "uso no cálculo de hashFunction2"
    },
    {
      "id": "U8",
      "variable": "wrappedInt",
      "type": "c-use",
      "description": "uso na escrita em buckets[hash]"
    },
    {
      "id": "U9",
      "variable": "temp",
      "type": "c-use",
      "description": "uso na realocação de chaves"
    },
    {
      "id": "U10",
      "variable": "size",
      "type": "c-use",
      "description": "uso na atualização do estado da tabela"
    }
  ],

  "du_paths": [
    {
      "id": "P0",
      "description": "tabela cheia antes da inserção",
      "post_condition": "rehash da tabela antes da tentativa de inserção"
    },
    {
      "id": "P1",
      "description": "chave duplicada detectada",
      "post_condition": "lançamento de IllegalArgumentException"
    },
    {
      "id": "P2",
      "description": "inserção direta após hashFunction1",
      "post_condition": "chave inserida sem realocação"
    },
    {
      "id": "P3",
      "description": "realocação simples com inserção após hashFunction2",
      "post_condition": "chave inserida após deslocamento"
    },
    {
      "id": "P4",
      "description": "realocação repetida até limite de iteração",
      "post_condition": "rehash seguido de nova tentativa de inserção"
    }
  ],

  "planned_tests": [
    {
      "test_id": "T0",
      "covers": ["P0"],
      "asserts": ["rehash ocorre antes da inserção"]
    },
    {
      "test_id": "T1",
      "covers": ["P1"],
      "asserts": ["IllegalArgumentException lançada"]
    },
    {
      "test_id": "T2",
      "covers": ["P2"],
      "asserts": ["inserção direta no primeiro hash"]
    },
    {
      "test_id": "T3",
      "covers": ["P3"],
      "asserts": ["realocação simples e inserção correta"]
    },
    {
      "test_id": "T4",
      "covers": ["P4"],
      "asserts": ["rehash após limite de iterações"]
    }
  ],

  "constraints": {
    "all_defs_covered": true,
    "all_p_uses_covered": true,
    "all_c_uses_covered": true,
    "all_decision_outcomes_covered": true,
    "observable_contract_preserved": true
  }
}

[5] Geração do Código Final (JUnit 5)

Com base exclusivamente no Program-of-Thoughts definido na etapa anterior,gere como resultado final o código Java completo, compilável e executável
da classe de teste JUnit 5 para o método public void insertKey2HashTable(int key).

[6] Convenções e Restrições Sintáticas

- O código Java final NÃO deve conter JSON sob nenhuma forma;
- Qualquer classe de teste que inclua JSON dentro do código Java é considerada inválida;
- Os casos de teste devem garantir cobertura de todos os caminhos definidos no Program-of-Thoughts;
- Não incluir comentários, explicações ou texto fora do código Java;
- Nomes dos testes devem seguir o padrão: testInsertKey2HashTable_*.

